/// Test tuples whose fields can be generated by `rand::random`
use std::collections::HashSet;
use enum_derived::Rand;
use rand::{thread_rng, Rng};

const MAX_AGE: u8 = 120;

fn rand_float(_rng: &mut impl Rng) -> RandomTypes {
    RandomTypes::FloatingPoint(0.0, 0.0)
}

fn rand_age(_rng: &mut impl Rng) -> RandomTypes {
    RandomTypes::Age(rng.gen_range(0..MAX_AGE))
}

#[derive(Rand)]
pub enum RandomTypes {
    Empty,
    Boolean(bool),
    #[custom_rand(rand_float)]
    FloatingPoint(f32, f64),
    #[custom_rand(rand_age)]
    Age(u8),
}

fn main() {
    let mut seen_variants = HashSet::new();

    for _ in 0..200 {
        let rt = RandomTypes::rand();
        match rt {
            RandomTypes::FloatingPoint(x, y) => {
                assert_eq!(x, 0.0);
                assert_eq!(y, 0.0);
            },
            RandomTypes::Age(age) => {
                assert!(age <= MAX_AGE);
            }
            _ => {}
        }
        seen_variants.insert(std::mem::discriminant(&rt));
    }

    // The values contained in the variant do not affect the discriminant
    assert!(seen_variants.contains(&std::mem::discriminant(&RandomTypes::Empty)));
    assert!(seen_variants.contains(&std::mem::discriminant(&RandomTypes::Boolean(false))));
    assert!(seen_variants.contains(&std::mem::discriminant(&RandomTypes::FloatingPoint(1.0, 1.0))));
    assert!(seen_variants.contains(&std::mem::discriminant(&RandomTypes::Age(0))));
}
